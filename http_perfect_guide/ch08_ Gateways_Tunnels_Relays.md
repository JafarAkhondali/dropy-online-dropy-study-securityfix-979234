# 통합점: 게이트웨이, 터널, 릴레이

## 8.1 게이트 웨이
- 게이트웨이 등장 이유: 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다. 
  - 때문에 리소스를 받기 위한 경로를 안내하는 역할을 하는 게이트에이 고안
- 게이트 웨이란?
  - **리소스와 애플리케이션을 연결하는 역할을 한다.**
  - 요청을 받고 응답을 보내는 포털 같이 동작하는데, **동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있다.**
  - HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 한다.
- 게이트웨이 예시 3가지
  - HTTP/FTP 서버 측 FTP 게이트웨이
    - 게이트웨이는 FTP URL을 가리키는 HTTP 요청을 받고, FTP 커넥션을 맺고 FTP 서버에 적절한 명령을 전송한다.
  - HTTPS/HTTP 클라이언트 측 보안 게이트웨이
    - 게이트웨이는 암호화된 웹 요청을 SSL을 통해 받고, 요청을 해독해서 생성한 일반 HTTP 요청을 목적지 서버로 전달한다.
  - HTTP/CGI(혹은 다른 API) 서버 측 애플리케이션 게이트웨이
    - 게이트웨이는 애플리케이션 서버 게이트웨이 API를 통해서 HTTP 클라이언트를 서버 측 애플리케이션 프로그램에 연결한다.

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이
- 웹 게이트웨이는 한쪽에서는 HTTP로 통신하고, 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다.
- 종류
  - 클라이언트 측 프로토콜
    - 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신한다.
  - 서버 측 프로토콜
    - 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신한다.
- 빗금(/)으로 구분
  - HTTP/FTP
  - HTTPS/HTTP

## 8.2 프로토콜 게이트웨이
> 네트워크상에서 클라이언트와 서버를 연결하는 게이트웨이
- 브라우저에 명시적으로 게이트웨이를 설정하여, 자연스럽게 트래픽이 게이트웨이를 거쳐 가게 할 수 있다.
- 게이트웨이를 대리 서버(리버시 프락시)로 설정할 수 있다.
- 일반적인 HTTP 트래픽에는 영향을 끼치지 않는다.
  - 브라우저는 일반 HTTP 트래픽은 원 서버로 바로 보낸다.
  - 하지만, FTP URL을 포함한 요청을 게이트웨이로 HTTP 요청을 보낸다.
  - 게이트웨이는 클라이언트 측의 요청을 FTP 요청으로 변환하여 처리한 뒤, 클라이언트에게 그 결과를 HTTP로 전송한다.

### 8.2.1 HTTP/*: 서버 측 웹 게이트웨이
- 서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다.
- 게이트웨이는 원 서버로부터 객체(데이터)를 받는 대로 HTTP 응답에 실어서 클라이언트에 전송한다.

### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이
- 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는 게이트웨이
- 클라이언트는 일반 HTTP를 사용하여  웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화한다.

### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이
- HTTPS/HTTP 게이트웨이는 웹 서버의 앞단에 위치한다.
- 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 한다.
  - 인터셉트 게이트웨이
    - 클라이언트에게 보이지 않는다.
    - 네트워크 흐름에서 클라이언트에서 서버로 가는 트래픽을 가로채 캐시된 응답을 돌려주는 등의 일을 한다.
  - 리버스 프락시
    - 클라이언트를 대신해서 한 대 이상의 서버로부터 자원을 추출하는 프록시 서버의 일종
- 이 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다.
- 원 서버보다 더욱 표율적으로 보안 트래픽을 복호화 하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 한다.
- 하지만, 게이트웨이와 원 서버 간의 암호화하지 않은 트래픽을 전송하기 때문에, 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 확실하고 사용해야 한다.

## 8.3 리소스 게이트웨이
> 웹 서버가 애플리케이션과 통신하는 수단
- 애플리케이션 서버
  - 목적지 서버와 게이트웨이를 한 개의 서버로 결합
  - HTTP를 통해서 클라이언트와 통신하고, 요청을 서버에서 동작하고 있는 애플리케이션에 전달하는 서버 측 게이트웨이
- CGI(공용 게이트웨이 인터페이스, Common Gateway Interface)
  - **애플리케이션 게이트웨이**에서 유명했던 최초의 API
  - CGI는 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하고, HTTP 응답으로 회신하는데 웹 서버가 사용하는 **표준화된 이터페이스 집합**이다.
  - 게이트웨이를 통해 받을 수 있는 리소스에 대한 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리한다.

### 8.3.1 공용 게이트웨이 인터페이스
- 공용 게이트웨이 인터페이스는 최초의 서버 확장이자 지금까지도 가장 널리 쓰이는 서버 확장이다.
  - 웹에서 동적인 HTML, 신용카드 처리, 데이터베이스 질의 등을 제공하는 데 사용한다.
- CGI 애플리케이션이 서버와 분리되면서, 펄(Perl), Tcl, C, 다양한 셸 언어를 포함하여 수많은 언어로 구현할 수 있다.
- CGI는 단순하므로, 거의 모든 HTTP 서버가 지원한다.
- CGI가 내부에서 어떤 처리를 하는지는 사용자에게 보이지 않는다.
  - 사용자의 시각에서는 CGI가 내부적으로 일반적인 요청을 만드는 것일 뿐이다.
  - 또한 서버와 CGI 애플리케이션 간에 진행되는 처리 단계를 감춘다.
- CGI의 성능 이슈
  - 모든 CGI 요청마다 새로운 프로세스를 만드는 데 따르는 부하가 꽤 크다.
- CGI 성능 이슈 문제를 피하고자 새로운 CGI 형식인 Fast CGI 개발
  - CGI와 유사하지만, 데몬으로 동작함으로써 요청마다 새로운 프로세스를 만들고 제거하면서 생기는 성능 저하 문제 해결
  - 요청이 있을 때마다 프로세스가 만들어지는 것이 아니라, 만들어진 프로세스가 계속해서 새로운 요청들을 처리한다. 즉, 프로세스 생성/제거에 드는 부하가 줄어든다.

### 8.3.2 서버 확장 API
- 서버 자체의 동작을 바꾸고 싶거나, 서버의 처리 능력을 최고치로 끌어올리고자 할 때 사용한다.
- 개발자가 서버의 동작을 변경하거나 다른 리소스에 대한 사용자 맞춤 인터페이스를 제공하는 데 사용하는 API
- 프론트페이지 서버 확장(FrontPage Server Extension, FPSE)
  - FPSE는 프론트페이지 클라이언트로부터 전송되는 원격 프로시져 호출(remote procedure call, RPC) 명령을 인식할 수 있다.
  - 이 명령은 HTTP에 편승하여 온다.

## 8.4 애플리케이션 인터페이스와 웹 서비스
- 인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합을 개발하였다.
- 웹 서비스
  - 애플리케이션 정보를 공유하는데 사용하는 새로운 메커니즘을 의미한다.
  - HTTP 같은 표준 웹 기술 위에서 개발한다.
  - 현대 웹 서비스의 데이터 교환 방식은 REST 방식을 더 많이 쓰며, 데이터 포맷도 JSON을 주로 사용한다.
  
## 8.5 터널
- 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다.
- 웹 터널을 사용하면, HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다.
- 웹 터널을 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해서다.

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기
- 웹 터널은 HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺는다.
- CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 **TCP 커넥션**을 맺고, 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청한다.
- CONNECT 메서드는 모든 서버나 프로토콜에 TCP 커넥션을 맺는데 사용할 수 있다.

#### CONNECT 요청
- 시작줄을 제외하고는 다른 HTTP 메서드와 가다.
- 요청 URI는 호스트 명이 대신하며, 콜론에 이어 포트를 기술한다.
- 시작줄 다음에는 다른 HTTP 메시지와 같이, 추가적인 HTTP 요청 헤더 필드가 있거나 없다. 

#### CONNECT 응답
- 일반 HTTP 메시지와 같이 200 응답 코드는 성공을 뜻한다.
- 편의상 응답에 있는 사유구절은 'Connection Established'로 기술한다.
- 일반적인 HTTP 응답과는 달리 Content-Type 헤더를 포함할 필요는 없다.
  - 커넥션이 메시지를 전달하는 대신 바이트를 그대로 전달하기 때문

### 8.5.2 데이터 터널링, 시간, 커넥션 관리
- 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없다.
  - 터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.
- 터널의 양 끝단에서는 두 커넥션으로부터 언제든지 패킷을 받을 수 있는 준비를 해야 하고, 그 데이터를 즉시 전달해야 한다.
  - 터널의 한쪽 끝단에서 데이터를 소비하지 않으면, 터널의 다른 끝단의 데이터 생산자는 행에 걸리게 될 것이고, 결국 교착상태가 일어날 수 있다.
- 클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송할 수 있다.
  - 요청에 이어서 데이터를 적절하게 처리할 수 있어야 함을 전제로 한다.
- 요청 후에 터널을 통해 데이터를 전송한 클라이언트는 인증 요구(authentication challenge)나 200외의 응답이 왔을 때 요청 데이터를 다시 보낼 준비가 되어 있어야 한다.
  - 터널의 끝단 어느 부분이든 커넥션이 끊어지면, 그 끊어진 곳으로부터 온 데이터는 반대편으로 전달된다.
  - 커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려진다.

### 8.5.3 SSL 터널링
- 웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발되었다.
- 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있다.
  - SSL 같이 암호화된 프로토콜은 정보가 암호화되어 있기 때문에 낡은 방식의 프락시에서는 처리되지 않는다.
- HTTP 터널링 기능
  - SSL 트래픽이 기존 프락시 방화벽을 통과할 수 있도록 HTTP에 터널링 기능이 추가되었다.
  - 이 터널링 기능은 HTTP 메시지에 암호화된 날 데이터를 담고 일반 HTTP 채널을 통해 데이터를 전송한다.
  - HTTP 메시지에 담겨 HTTP 포트인 80에 전송된다.
- 터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해준다.
  - 이는 보안 SSL 트래픽이 방화벽을 통과하는 데 유용하게 사용될 수 있다. 
  - 하지만, 터널은 악의적인 트래픽이 사내로 유입되는 경로가 될 수도 있다.

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이
- HTTP/HTTPS 게이트웨이
  - 원격 HTTPS 서버와 SSL세션을 시작하는 게이트웨이를 두고, 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식
  - 응답은 프락시가 받아서 복호화하고 난 후에, HTTP(보안이 좋지 않은)를 통해 클라이언트로 전송한다.
- HTTP/HTTPS 게이트웨이의 단점
  - 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있다.
  - 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증(X509 인증서 기반의 인증)을 할 수 없다.
  - 게이트웨이는 SSL을 와벽히 지원해야 한다.
- SSL 터널링을 사용하면, 프락시에서 SSL을 구현할 필요가 없다.
  - SSL 세션은 클라이언트가 생성한 요청과 목적지(보안이 적용된) 웹 서버 간에 생성된다.
  - 프락시 서버는 트랜잭션의 보안에는 관여하지 않고, 암호화된 데이터를 그대로 터널링 할 뿐이다.

### 8.5.5 터널 인증
- 프락시 인증 기능은 **클라이언트가 터널을 사용할 수 있는 권한을 검사**하는 용도로 터널에서 사용할 수 있다.

### 8.5.6 터널 보안에 대한 고려 사항들
- 보통, 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 **올바른 용도로 사용하고 있는지 검증**할 방법이 없다.
- 터널의 오용을 최소화하기 위해서, 게이트웨이는 HTTPS 전용 포트인 443 같이 **잘 알려진 특정 포트**만을 터널링 할 수 있게 허용해야 한다.

## 8.6 릴레이
- HTTP 릴레이는 HTTP 명시를 완전히 준수하지는 않는 **간단한 HTTP 프락시**다.
- 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, **바이트를 맹목적으로 전달**한다.
- HTTP는 복잡하기에, 모든 헤더와 메서드 로직을 수행하지 않고, 맹목적으로 트래픽을 전달하는 간단한 프락시를 구현하는 방식이 유용할 때가 있다.
  - 단순 필터링이나 진단 혹은 콘텐츠 변환을 하는데 사용된다.
    - 하지만, 이는 잠재적으로 심각한 상호 운용 문제를 갖고 있기 때문에 주의해서 배포해야 한다.
- 릴레이를 구현하는데 관련된 일반적인 문제
  - 맹목적 릴레이가 Connection 헤더를 제대로 처리하지 못해서 keep-alive 커넥션이 행(hang)에 걸리는 것이다.
- 이러한 문제를 예방하기 위해 릴레이를 조금이나마 똑똑하게 만드는 방법이 있지만, 상호 운용과 관련된 문제가 발생할 위험이 있기 때문에 신중히 고민해봐야 한다.
- 여러 문제를 예방하기 위해서, HTTP를 제대로 준수하는 프락시를 이용하는 게 좋다.