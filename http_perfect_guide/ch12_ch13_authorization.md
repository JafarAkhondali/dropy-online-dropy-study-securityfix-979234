# 인증

보통 form과 쿠키 등 이용하여 자체적으로 인증모듈 만든다.

## Http에서 제공하는 인증 방법
### 인증 프로토콜
    - 기본 인증
    - 다이제스트 인증
    - OAuth
### 기본 인증
1. 클라이언트 -> 서버 : get 요청
2. 서버 -> 클라이언트 : 401 응답 / WWW-Authenticate 헤더 사용 / realm 파라미터로 보안영역 기술
3. 클라이언트 -> 서버 : 인증정보 base-64로 인코딩하여 헤더에 담아 get요청 / Authorization헤더 사용
4. 서버 -> 클라이언트 : 응답 200/ (다이제스트 Authentication-info 헤더에 추가 정보 기술하기도 함)

### 프락시 인증
- 접근 정책 중앙관리 라기 위해 프락시 서버 사용 
- 기본인증과 절차는 같지만 상태코드, 인증 헤더 다름


### 보안 결함
- 누구나 디코딩할 수 있음
- 인증정보 가로채서 재전송 공격 가능
- 비슷한 인증정보 쓴다면 다른 계정도 위험 노출
- 가짜 서버, 중개자 등의 개입에 방어 불가
- 따라서 예방 차원에서 쓰이고, 리얼 보안은 SSL과 연계하여 사용함

---
## 다이제스트(요약) 인증
현재 그다지 사용되지는 않고 있다
기본인증보다 훨씬 강력하지만, SSL이 있는데 굳이? 느낌..
왜냐면 비밀번호에 대해서는 SSL 비슷한 효과를 볼수 있지만 나머지 데이터에 대해서는 그대로 노출되기 때문

- 비밀번호를 네트워크 통해 평문으로 전송하지 않는다.
- 인증체결을 가료채서 재현하려는 시도 차단
- 메시지 내용 위조 막는 것 가능

### 비밀번호 요약(digest) 사용
- 클: 서버에 보호된 데이터 요청
- 서: 사용자 이름과 요약 형태의 비밀번호요청
- 클: 비밀번호 요약 전달
- 서: 받은 요약과 서버가 내부적으로 계산한 요약 비교/ 일치 시 데이터 전송

요약함수는 암호 체크섬으로 불리며 단방향 해시 함수이거나 지문함수이다.
인기있는 요약함수로 MD5, SHA가 있다.

### 난스(nonce)사용
요약을 사용하면 비밀번호를 해킹하는 것은 불가능하지만, 요약 자체를 가로채는 것은 어떻게 방어할까?
인증마다 혹은 1ms마다 바뀌는 **난스**값을 비밀번호에 섞어 매번 요약이 바뀌게 만든다.
따라서 요약을 가로채서 요청을 재전송하더라도 난스값으로 인해 무효하다.
난스값은 WWW-Authenticate인증요구에 담겨 서버에서 클라이언트로 전달된다.

- 클: 서버에 보호된 데이터 요청
- 서: 사용자 이름과 요약 형태의 비밀번호 요청 시, 난스 값 계산하여 WWW-Authenticate인증요구 메시지에 담아 서버가 지원하는 알고리즘 목록과 함께 전송
- 클: 알고리즘 선택하고 Authorization메세지에 요약 담아 전달 / 서버 인증을 원한다면 마찬가지로 클라이언트 난스 보냄
- 서: 받은 요약과 서버가 내부적으로 계산한 요약 비교/ 일치 시 데이터 전송 / 다음번 난스를 미리 계산해서 클라이언트에게 전송

### 요약 계산
- 단방향 해시 함수 / 요약함수로 **보안 관련 데이터**와 **메시지 관련 데이터**를 처리하여 요약을 만든다.
- 여러가지 요약 알고리즘 선택할수 있지만 디폴트는 MD5
#### RFC 2617은 **보안 관련 데이터** 계산하기 위한 두가지 방법을 정의한다. 
- MD5 
    - 보안데이터 = 사용자 데이터 콜론으로 연결한 것 
    - 모든 요청마다 보안데이터에 대해 단방향 해시 실행
- MD5-sess
    - 보안데이터 = MD5(사용자 데이터 콜론으로 연결한 것)+난스
    - 해시계산은 WWW-Ahthenticate 핸드셰이크할때 한번만 수행
#### RFC 2617은 **메시지 관련 데이터**에 대해 두가지 사용법을 정의한다.
- qop="auth" or default
    - Http 요청메서드 + url
- qop="auth-init"
    - Http 요청메서드 + url + 메세지 엔터티 본문
#### cf. 보호수준(qop) 향상
- qop 필드는 WWW-Authenticate, Authorization, Authentication-Info에 모두 존재 가능
- qop 필드는 클라이언트와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 수 있지 협상할 수 있게 허용
- qop=”auth-int”면 메시지 무결성 보호가 적용
- auth-int의 경우 계산되는 메시지 관련 데이터가 메시지 본문의 해시가 아닌 엔티티 본문의 해시
#### RFC 2617 요약을 계산하는 두가지 방법 정의한다.
- qop정의되지 않았을 때 - (..)
- qop옵션 정의 되었을 때 - (..)

### 다이제스트 인증 세션
WWW-Authenticate 인증 요구에 대한 클라이언트의 응답은 보호공간에 대한 인증 세션을 시작하게 한다.세션은 클라이언트가 보호공간의 또다른 서버로부터 인증요구 받을때까지 지속된다.

#### 사전인가
클라이언트가 WWW-Authenticate 인증 요구 기다리지 않고 난스 취득해야한다.
- 셔벼갸 다음번 난스를 미리 계산해서 Authentication-Info 성공 헤더에 담아 전송한다.
    - 트랜잭션 속도 향상 but 다중 요청 파이프라이닝 하는 회전지연 회피는 불가능
- 서버가 짧은 시간동안 난스 재사용을 허용한다.
    - 다중 요청 파이프라이닝 가능 but 보안성 감소
- 클라이언트와 서버 동기화, 예측 가능한 난스생성 알고리즘을 사용한다.

#### 난스 선택
- 구현하기 나름
- 타임스탬프, 요청된 엔터티에 대한 Etag 헤더값, 서버만 알고 있는 개인키 등으로 만들수 있음
- 서버는 난스의 유효기간을 제한할수 있음

#### 상호 인증
- RFC 2617은 클라이언트도 서버를 인증할 수 있도록 다이제스트 인증을 확장함 
- 클라이언트 난스값을 제공함으로서 가능
- qop옵션이 있을 때는 항상 상호인증 해야함

### 다이제스트 인증 헤더
- WWW-Authenticate : 인증 요구
- Authorization: 인가 응답
- Authentication-Info : 선택적, 다음번 난스 전달

### 실제상황
- 다중 인증 요구
    - 기본인증, 요약인증 둥을 동시에 요구할 경우 클라이언트는 지원할수 있는 가장 강력한 인증 매커니즘을 선택해야 한다.
- 오류 처리
    - 인증 실패 시 400 bad request 응답
    - 실패 로그 기록해두는 것이 좋음 - 공격 추측 가능
    - uri 지시자의 리소스가 요청줄의 리소스와 같은지 확인 필요, 아니라면 중간 프락시가 요청줄 변조했을 가능성 있음
- 보호 공간
    - 자격이 자동으로 적용되는 영역
    - 보호공간을 구체적으로 지정하는 것은 인증 매커니즘에 달려있음
- URI 다시쓰기
    - 프락시가 url을 변경할 경우 다이제스트 인증 실패할 수 있음
- 캐시
    - 공유캐시가 인증 헤더 포함한 응답을 가지고 있는 경우 must-revalidate or pulic Cache-Control 이 응답에 없으면 다른 요청에 캐시를 반환하면 안된다.


### 보안에 대한 고려사항
- 헤더 부당 변경
    - 양 종단 암호화
    - 헤더에 대한 디지털 서명
- 재전송 공격
    - 완전히 피할수 있는 방법은 매 트랜잭션마다 유일한 난스값 사용하는 것
- 다중 인증 메커니즘
    - 클라이언트는 서버에서 제공하는 인증 선택지 중 가장 강력한 것을 선택해야한다
- 사전(dictionary) 공격
    - 복잡한 비밀번호사용 
    - 비밀번호 만료정책
- 악의적인 프락시와 중간자 공격
    - 유일한 해결책은 SSL
- 선택 평문 공격
    - 클라이언트에게 가짜 난스보내 응답받고 암호 해독하기
    - 클라이언트가 서버에서 제공한 난스 대신 선택적인 난스 지시자를 사용할수 있도록 설정
- 비밀번호 저장
    - 다이제스트 인증 비밀번호 유출시 걍 끝장
