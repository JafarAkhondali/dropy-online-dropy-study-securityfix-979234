# 커넥션 관리

## 1. HTTP 통신 흐름을 TCP Socket API와 함께 보기

![figure4_1](https://user-images.githubusercontent.com/47515936/79689790-fc1f4d00-8291-11ea-94e5-ed4ae1e1d051.png)

## 2. HTTP 성능에 영향을 미치는 TCP 요소들

### 2.1. TCP 커넥션 핸드셰이크 지연

작은 HTTP 트랜잭션의 경우 50% 이상이 핸드셰이크 비용이다. 따라서 다음의 개선책들을 활용한다.

1. **마지막 ACK 응답에 요청 메시지를 포함**해서 전달한다.
2. **확인응답 지연 알고리즘**
    - 확인응답을 0.1 ~ 0.2초 버퍼에 저장해두고, 패킷에 편승시킨다.
    - 안타깝게 HTTP 프로토콜은 요청 > 응답의 메커니즘을 가지기 때문에 확인응답 지연으로 득을 보기보다는 실이 발생하는 경우가 더 많다.

### 2.2. TCP 의 느린 시작

TCP 커넥션은 만들어질 때 느리지만, **데이터가 성공적으로 전송됨에 따라 튜닝되며 속도가 높아진다.**  
이는 인터넷의 급작스러운 부하를 막는다. 따라서 성능을 개선하기 위해 튜닝된 커넥션을 재사용하는 **지속 커넥션**을 사용한다.

### 2.3. Nagle 알고리즘

네트워크의 효율을 위해서 하나의 패킷에 최대한 많은 데이터를 보내는 것이다.
이는 **패킷의 최대 크기를 만족시키거나, ACK를 받았을 경우에만 패킷의 전송을 허락**한다.

따라서 **크기가 작은 HTTP 패킷의 경우 불필요한 지연이 발생**하며, 확인응답 지연 알고리즘이나 커넥션의 파이프라이닝으로 지연이 더욱 커질 수 있다.

이를 제어하기 위해 TCP_NODELAY 파라미터를 설정하기도 한다.

<img width="1000" alt="nagle algorithm" src="https://user-images.githubusercontent.com/47515936/79690060-7d2b1400-8293-11ea-89d3-df3f10e5b8b3.png">

### 2.4. TIME_WAIT 누적과 포트 고갈

TCP 커넥션은 안정성을 위해 TIME_WAIT 단계를 갖는다.  
따라서 클라이언트에서 막대한 요청을 보내게 되면 새로운 발신지 포트를 활용하다가 포트 고갈이 올 수 있다.  
포트 고갈이 되지 않더라도, 커넥션이나 제어블록이 너무 많을 때 운영체제에 따라 느려지는 경우도 있다.

다음은 TIME_WAIT를 사용하는 이유에 대한 간단한 정리이다.

![tcp_time_wait](https://user-images.githubusercontent.com/47515936/79690136-d98e3380-8293-11ea-97d3-e2504040c7dc.png)

## 3. HTTP 커넥션 성능 향상 기술

### 3.1. 병렬 커넥션

- 장점 1. 남은 인터넷 대역폭을 나머지 객체를 받는 데 사용이 가능하다
- 장점 2. 지연시간이 겹쳐서 총 지연시간이 줄어든다
- 단점 1. 클라이언트의 네트워크 대역폭이 작다면 의미가 없다
- 단점 2. 커넥션에 따른 메모리 소모가 크다
- 단점 3. 각각의 커넥션 지연문제가 있다

> 브라우저는 보통 4개의 병렬 커넥션만 허용한다.

![parallel connection](https://user-images.githubusercontent.com/47515936/79690237-62a56a80-8294-11ea-959f-31dc39a2e1f8.png)

### 3.2. 지속 커넥션

- 요청에 `Connection: close` 헤더를 포함해서 보내면, 그 커넥션으로 추가적인 요청을 보낼 수 없다.
- 추가 요청을 보내지 않을 것이라면, 마지막 요청에 `Connection: close`를 보내야 한다.
- 청크 인코딩을 하거나, 정확한 Content-Length 를 반드시 포함시켜야한다.
- 프락시는 클라이언트 서버 각각에 대해 별도의 지속 커넥션을 관리해야 한다.
- 프락시는 클라이언트 지원범위를 모를 때 지속 커넥션을 맺으면 안된다.
- Connection 헤더와 관련없이 커넥션을 언제든 끊을 수 있다.
- 각각의 클라이언트는 각자 두개의 지속 커넥션만 유지 가능하다.

![continuous connection](https://user-images.githubusercontent.com/47515936/79690353-f9722700-8294-11ea-9588-5cb6d60e151f.png)


