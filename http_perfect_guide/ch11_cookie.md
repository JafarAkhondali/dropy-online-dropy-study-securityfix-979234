# 클라이언트 식별과 쿠키

## HTTP 헤더를 이용하기

1. `From` 헤더 사용하기
    - 개요: 사용자의 이메일을 넣는 헤더값으로, 이상적으로는 각 사용자가 다른 이메일 주소를 가지기 때문에 사용이 가능한 방식이다
    - 단점: 서버측에서 이메일 주소를 이용해서 악의적인 스팸 메일을 보낼 수 있다
2. `UserA-Agent` 헤더 사용하기
    - 개요 : 브라우저 이름과 버전, 운영체제에 대한 정보까지 포함한다
    - 단점 : 사용자들을 식별하는데는 큰 도움이 되지 않는다 (기기 식별용)
3. `Referer` 헤더 사용하기
    - 개요 : 유입된 URL을 가리킨다.
    - 단점 : 어디에서부터 유입되었는지는 확인 가능하지만, 결국 사용자 식별은 할 수 없다.
4. `Authorization` 헤더 사용하기
    - 개요 : 토큰 인증 방식을 의미한다. 타입을 지정해서 해당 토큰이 어떤 타입의 토큰인지 명시한다.
    - 단점 : 토큰이 탈취되었을 때의 보안에 대해 고민해봐야 한다.

## IP 주소 이용하기

HTTP 헤더값을 사용했을 때와 달리 어느정도 사용자 식별이 가능합니다.  
하지만 역시 다음과 같은 제약사항이 있습니다.

1. 여러 사용자가 같은 컴퓨터를 사용한다
2. 인터넷 서비스 제공자를 끼고있는 경우에 IP주소가 동적할당 된다
3. 보안을 위한 방화벽이 실제 IP를 숨기고 방화벽 IP를 주는 경우도 있다
4. 프락시와 게이트웨이를 거칠 경우 실제 IP와 다른 IP를 받게 될 것이다

## 뚱뚱한 URL 이용하기

사용자 인증에 대한 문자열을 URL에 포함시킴으로써 인증하는 것을 말합니다.  
다음과 같은 문제가 있을 수 있습니다.

1. 공유하지 못하는 URL
    - 개요 : URL 자체가 인증을 포함하기 때문에 다른 사람들에게 공유하기 위험하다
2. 캐시를 사용이 까다롭다
    - 개요 : 동일한 리소스 주소에 대해서 모두 각기 다른 URL을 가지기 때문에 캐시하기 까다롭다
3. 세션 이탈
    - 개요 : 특정 URL로 리다이렉션하는 경우, 예상치 못하게 세션에서 이탈될 수 있다.

## 쿠키

쿠키가 어떤건지는 다들 알 것이라 생각해서 정리하지 않았으며,  
간단히 특징만 정리해보면 아래와 같습니다.

- 일반적으로 브라우저는 쿠키를 캐싱하지 않는다
- 쿠키는 크게 파기시점(`Discard`, `Expires`, `Max-Age`)이 정의되었냐에 따라 지속쿠키와 세션쿠키로 나뉜다
- 서버는 `Set-Cookie` 헤더값을 이용해서 쿠키를 등록할 수 있다
- 클라이언트는 `Cookie` 헤더값을 이용해서 쿠키를 보낸다
- `RFC 6265` 표준에 따르면 도메인당 50개, 전체 3000개, 1개당 약 4MB 저장이 가능해야한다고 명시하고 있다
- `key/value` 형태로 저장이 가능하다

### 쿠키의 옵션들

- 보안 관련
    - Secure : 암호화가 진행될 경우 (ssl) 허용
    - HttpOnly : 클라이언트에서 `document.cookie` 허용
    - SameSite : 크로스 도메인 요청의 경우 쿠키값이 포함되지 않는다 (실험단계)
- 스코프 관련
    - Domain : 도메인 스코프 (ex. `dropy.online -> mobile.dropy.online` 허용)
    - Path : Url 경로 스코프 (ex. `/home -> /home/subpath` 허용)
- 영속성 관련
    - Expires : 만료날짜를 설정한다
    - Max-Age : 남아있을 수 있는 기간을 설정한다.
